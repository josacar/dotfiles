# fresh: shell/bashrc

# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
*i*) ;;
*) return ;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
#[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
  debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
xterm-color | *-256color) color_prompt=yes ;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
#force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
  if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
    # We have color support; assume it's compliant with Ecma-48
    # (ISO/IEC-6429). (Lack of such support is extremely rare, and such
    # a case would tend to support setf rather than setaf.)
    color_prompt=yes
  else
    color_prompt=
  fi
fi

if [ "$color_prompt" = yes ]; then
  PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
else
  PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm* | rxvt*)
  PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
  ;;
*) ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
  test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
  alias ls='\ls --color=auto'
  alias dir='\dir --color=auto'
  #alias vdir='vdir --color=auto'

  alias grep='\grep --color=auto'
  alias fgrep='\fgrep --color=auto'
  alias egrep='\egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
#alias ll='ls -l'
#alias la='ls -A'
#alias l='ls -CF'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
  . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# fresh: shell/profile

## Customizations

set -o vi

set editing-mode vi
set keymap vi
set convert-meta on

bind -m vi-insert "\C-l":clear-screen
bind '"\e\C-e": alias-expand-line'
bind 'RETURN: "\e\C-e\n"'

export GPG_TTY=$(tty)

PS1='${debian_chroot:+($debian_chroot)}\[\033[1;32m\]\u\[\033[00m\]:\[\033[01;34m\]\w'

if declare -F __git_ps1 > /dev/null ;then
  PS1="${PS1}\[\033[1;31m\]\$(__git_ps1 \" (%s)\")"
fi

PS1="${PS1}\[\033[00m\]\$ "

for dir in tmp _backup undodir; do
  [ ! -d $HOME/.vim-tmp/$dir ] && mkdir -p $HOME/.vim-tmp/$dir
done

export TERM='xterm-256color'
export LC_ALL=en_US.UTF-8
export RIPGREP_CONFIG_PATH=$HOME/.ripgreprc
export XDG_DATA_DIRS="$HOME/.local/share/flatpak/exports/share:$XDG_DATA_DIRS"

if command -v starship &> /dev/null; then
  eval "$(starship init bash)"
fi

# fresh: shell/brew

#!/bin/bash

if [ "$(uname)" == "Darwin" ]; then
  if [ -f "/opt/homebrew/bin/brew" ]; then # Apple Silicon
    eval "$(/opt/homebrew/bin/brew shellenv)"
  elif [ -f "/usr/local/bin/brew" ]; then # Intel
    eval "$(/usr/local/bin/brew shellenv)"
  fi
fi

# fresh: shell/editor.sh

export EDITOR='vim'

# fresh: shell/aliases/git.sh

alias ga='git add'
alias gap='git add -p'
alias gar='git reset HEAD'
alias garp='git reset -p HEAD'
alias gau='git add -u'
alias gbd='gd $(git merge-base origin/HEAD HEAD)..'
alias gbl='glg $(git merge-base origin/HEAD HEAD)..'
alias gblp='glp $(git merge-base origin/HEAD HEAD)..'
alias gc='git commit -v'
alias gca='gc --amend'
alias gci='git commit'
alias gco='git checkout'
alias gcom='git checkout $(git_default_branch)'
alias gcp='git checkout -p'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdcw='gdw --cached'
alias gds='git diff --stated'
alias gdw='gd --word-diff=color --word-diff-regex="[A-z0-9_-]+"'
alias gfa='git fetch --all'
alias gfap='git fetch --all --prune'
alias gfapu='gfap && ggpull'
alias gl='glg $(git show-ref | cut -d " " -f 2 | grep -v stash$)'
alias gld="git fsck --lost-found | grep '^dangling commit' | cut -d ' ' -f 3- | xargs git show -s --format='%ct %H' | sort -nr | cut -d ' ' -f 2 | xargs git show --stat"
alias glg='git log --graph --pretty=format:"%Cred%h%Creset%C(yellow)%d%Creset %s %C(green bold)- %an %C(black bold)%cd (%cr)%Creset" --abbrev-commit --date=short'
alias gll='git log --decorate -p'
alias glw='glp --word-diff'
alias gp='git push'
alias gpt='git push -u origin $(git_current_branch)'
alias grc='git rebase --continue'
alias grom='git rebase origin/$(git_default_branch)'
alias gromi='git rebase origin/$(git_default_branch) -i'
alias grt='git_current_tracking > /dev/null && git rebase -i @{upstream}'
alias grv='git remote -v'
alias gs='git status'
alias gsh='git show'
alias gss='git status -sb'
alias gst='git stash --include-untracked --keep-index'
alias gstp='git stash pop'
alias gsu='git status -uno'
alias gwd='git update-ref -d refs/wip/$(git_current_branch)'
alias gws='git wip save WIP --untracked'

alias ggpull='git pull --rebase origin $(git_current_branch)'
alias gfpull='git pull -u fork --rebase origin $(git_current_branch)'
alias ggpush='git push origin $(git_current_branch)'
alias gfpush='git push -u fork $(git_current_branch)'
alias ggpushf='git push --force-with-lease origin $(git_current_branch)'

alias ghpull='git pull --rebase heroku $(git_current_branch)'
alias ghpush='git push heroku $(git_current_branch)'

# helper for git aliases

git_default_branch() {
  BRANCH=$(git rev-parse --abbrev-ref origin/HEAD)
  BRANCH="${BRANCH##origin/}"
  echo "$BRANCH"
}

git_current_branch() {
  BRANCH="$(git symbolic-ref -q HEAD)"
  BRANCH="${BRANCH##refs/heads/}"
  BRANCH="${BRANCH:-HEAD}"
  echo "$BRANCH"
}

git_current_tracking() {
  BRANCH="$(git_current_branch)"
  REMOTE="$(git config branch.$BRANCH.remote)"
  MERGE="$(git config branch.$BRANCH.merge)"
  if [ -n "$REMOTE" ] && [ -n "$MERGE" ]; then
    echo "$REMOTE/$(echo "$MERGE" | sed 's#^refs/heads/##')"
  else
    echo "\"$BRANCH\" is not a tracking branch." >&2
    return 1
  fi
}

gcm() {
  git commit -m "[$(git_current_branch)] $*"
}

# git log patch
glp() {
  # don't use the pager if in word-diff mode
  pager="$(echo "$*" | grep -q -- '--word-diff' && echo --no-pager)"

  # use reverse mode if we have a range
  reverse="$(echo "$*" | grep -q '\.\.' && echo --reverse)"

  # if we have no non-option args then default to listing unpushed commits in reverse moode
  if ! (for ARG in "$@"; do echo "$ARG" | grep -v '^-'; done) | grep -q . && git_current_tracking > /dev/null 2>&1
  then
    default_range="@{upstream}..HEAD"
    reverse='--reverse'
  else
    default_range=''
  fi

  git $pager log --patch $reverse "$@" $default_range
}

# git log file
glf() {
  git log --format=%H --follow -- "$@" | xargs --no-run-if-empty git show --stat
}

# git log search
gls() {
  phrase="$1"
  shift
  if [ $# -eq 0 ]; then
    default_range=HEAD
  fi
  glp --pickaxe-all -S"$phrase" "$@" $default_range
}

# checkout a GitHub pull request as a local branch
gpr() {
  TEMP_FILE="$(mktemp "${TMPDIR:-/tmp}/gpr.XXXXXX")"
  echo '+refs/pull/*/head:refs/remotes/origin/pr/*' > "$TEMP_FILE"
  git config --get-all remote.origin.fetch | grep -v 'refs/remotes/origin/pr/\*$' >> "$TEMP_FILE"
  git config --unset-all remote.origin.fetch
  while read -r LINE < "$TEMP_FILE"
  do
    git config --add remote.origin.fetch "$LINE"
  done
  rm "$TEMP_FILE"

  git fetch
  if [ -n "$1" ]; then
    git checkout "pr/$1"
  fi
}

gup() {
  # subshell for `set -e` and `trap`
  (
  set -e # fail immediately if there's a problem

  # use `git-up` if installed
  if type git-up > /dev/null 2>&1
  then
    exec git-up
  fi

  # fetch upstream changes
  git fetch

  BRANCH=$(git symbolic-ref -q HEAD)
  BRANCH=${BRANCH##refs/heads/}
  BRANCH=${BRANCH:-HEAD}

  if [ -z "$(git config branch.$BRANCH.remote)" ] || [ -z "$(git config branch.$BRANCH.merge)" ]; then
    echo "\"$BRANCH\" is not a tracking branch." >&2
    exit 1
  fi

  # create a temp file for capturing command output
  TEMPFILE="$(mktemp -t gup.XXXXXX)"
  trap '{ rm -f "$TEMPFILE"; }' EXIT

  # if we're behind upstream, we need to update
  if git status | grep "# Your branch" > "$TEMPFILE"
  then

    # extract tracking branch from message
    UPSTREAM=$(cut -d "'" -f 2 < "$TEMPFILE")
    if [ -z "$UPSTREAM" ]
    then
      echo Could not detect upstream branch >&2
      exit 1
    fi

    # can we fast-forward?
    CAN_FF=1
    grep -q "can be fast-forwarded" "$TEMPFILE" || CAN_FF=0

    # stash any uncommitted changes
    git stash | tee "$TEMPFILE"
    [ "${PIPESTATUS[0]}" -eq 0 ] || exit 1

    # take note if anything was stashed
    HAVE_STASH=0
    grep -q "No local changes" "$TEMPFILE" || HAVE_STASH=1

    if [ "$CAN_FF" -ne 0 ]
    then
      # if nothing has changed locally, just fast foward.
      git merge --ff "$UPSTREAM"
    else
      # rebase our changes on top of upstream, but keep any merges
      git rebase -p "$UPSTREAM"
    fi

    # restore any stashed changes
    if [ "$HAVE_STASH" -ne 0 ]
    then
      git stash pop
    fi

  fi

  )
}

gauv() {
  git ls-files --other --exclude-standard -z "$@" | xargs -0 git add -Nv
}

gaur() {
  git ls-files --exclude-standard --modified -z | xargs -0 git ls-files --stage | while read MODE OBJECT STAGE NAME; do
  if [ "$OBJECT" == e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 ]; then
    echo "reset '$NAME'"
    if git rev-parse --quiet --verify HEAD > /dev/null; then
      git reset -q -- "$NAME" 2>&1
    else
      git rm --cached --quiet -- "$NAME"
    fi
  fi
done
}

gcf() {
  if [ $(git diff --staged --name-only | wc -l) -lt 1 ]; then
    echo Nothing staged to commit. >&2
    return 1
  fi

  COMMITS="$(
  git diff --staged --name-only -z |
  xargs -0 git log --pretty=format:'%H %s' @{u}.. |
  awk '{ if ($2 != "fixup!") { print $1} }'
  )"

  case $(echo "$COMMITS" | grep -c .) in
    0)
      echo No fixup candidates found. >&2
      return 1
      ;;
    1)
      git commit --fixup "$COMMITS"
      ;;
    *)
      echo Staged files:
      git diff --staged --name-only | sed 's/^/  /'
      echo
      echo Multiple fixup candidates:
      echo "$COMMITS" | xargs git show -s --oneline | sed 's/^/  /'
      return 1
      ;;
  esac
}

# fresh: shell/aliases/misc.sh

alias less='\less -r'

command -v ack-grep > /dev/null
[ $? -eq 0 ] && alias ack='ack-grep'

command -v nvim > /dev/null
[ $? -eq 0 ] && alias vim='nvim'

command -v eza > /dev/null
[ $? -eq 0 ] && alias ls='eza'

alias vless='/usr/share/vim/vim80/macros/less.sh'
alias ..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."

# fresh: shell/aliases/rails.sh

alias rc='rails console'
alias rs='rails server'
alias ber=rspec
alias berd='RSPEC_FORMAT=doc ber'

function rspec-branch {
  rspec $(
    git diff $(git merge-base origin/HEAD HEAD).. --name-only |
    sed 's#^app/\(.*\)\.rb$#spec/\1_spec.rb#' |
    grep '_spec\.rb$' |
    sort -u |
    xargs find 2> /dev/null
  )
}

function rspec-work {
  rspec $(
    git status --porcelain -z --untracked-files=all | tr '\0' '\n' | cut -c 4- |
    sed 's#^app/\(.*\)\.rb$#spec/\1_spec.rb#' |
    grep '_spec\.rb$' |
    sort -u |
    xargs find 2> /dev/null
  )
}

# fresh: shell/aliases/ruby.sh

alias b='bundle'
alias bo='bundle open'
alias be='bundle exec'
alias ber='bundle exec rspec'
alias beh='BUNDLE_GEMFILE=$HOME/Gemfile bundle exec'

function rake
{
  if [ -f Gemfile ]; then
    bundle exec rake "$@"
  else
    command rake "$@"
  fi
}

function _bundle_spec_names() {
ruby <<-RUBY
  NAME_VERSION = '(?! )(.*?)(?: \(([^-]*)(?:-(.*))?\))?'
  File.open 'Gemfile.lock' do |io|
    in_specs = false
    io.lines.each do |line|
      line.chomp!
      case
      when in_specs && line == ''
        in_specs = false
      when line =~ /^ +specs:\$/
        in_specs = true
      when in_specs && line =~ %r{^ +#{NAME_VERSION}\$}
        puts \$1
      end
    end
  end
RUBY
}

function _bundle_open() {
  local curw
  COMPREPLY=()
  curw=${COMP_WORDS[COMP_CWORD]}
  COMPREPLY=($(compgen -W '$(_bundle_spec_names)' -- $curw));
  return 0
}
if type complete > /dev/null 2>&1; then
  complete -F _bundle_open bo
fi

# fresh: shell/completions/bash_completion

if [ "$(uname)" == "Darwin" ]; then
  if [ -n "$HOMEBREW_PREFIX" ]; then
    eval 'test -r "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh" && . "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh"'
  fi
fi

# fresh: shell/completions/git

# bash/zsh git prompt support
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Distributed under the GNU General Public License, version 2.0.
#
# This script allows you to see the current branch in your prompt.
#
# To enable:
#
#    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
#    2) Add the following line to your .bashrc/.zshrc:
#        source ~/.git-prompt.sh
#    3a) Change your PS1 to call __git_ps1 as
#        command-substitution:
#        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
#        ZSH:  PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
#        the optional argument will be used as format string.
#    3b) Alternatively, if you are using bash, __git_ps1 can be
#        used for PROMPT_COMMAND with two parameters, <pre> and
#        <post>, which are strings you would put in $PS1 before
#        and after the status string generated by the git-prompt
#        machinery.  e.g.
#           PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
#        will show username, at-sign, host, colon, cwd, then
#        various status string, followed by dollar and SP, as
#        your prompt.
#        Optionally, you can supply a third argument with a printf
#        format string to finetune the output of the branch status
#
# The argument to __git_ps1 will be displayed only if you are currently
# in a git repository.  The %s token will be the name of the current
# branch.
#
# In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,
# unstaged (*) and staged (+) changes will be shown next to the branch
# name.  You can configure this per-repository with the
# bash.showDirtyState variable, which defaults to true once
# GIT_PS1_SHOWDIRTYSTATE is enabled.
#
# You can also see if currently something is stashed, by setting
# GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
# then a '$' will be shown next to the branch name.
#
# If you would like to see if there're untracked files, then you can set
# GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked
# files, then a '%' will be shown next to the branch name.  You can
# configure this per-repository with the bash.showUntrackedFiles
# variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is
# enabled.
#
# If you would like to see the difference between HEAD and its upstream,
# set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates you are behind, ">"
# indicates you are ahead, "<>" indicates you have diverged and "="
# indicates that there is no difference. You can further control
# behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list
# of values:
#
#     verbose       show number of commits ahead/behind (+/-) upstream
#     legacy        don't use the '--count' option available in recent
#                   versions of git-rev-list
#     git           always compare HEAD to @{upstream}
#     svn           always compare HEAD to your SVN upstream
#
# By default, __git_ps1 will compare HEAD to your SVN upstream if it can
# find one, or @{upstream} otherwise.  Once you have set
# GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by
# setting the bash.showUpstream config variable.
#
# If you would like to see more information about the identity of
# commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE
# to one of these values:
#
#     contains      relative to newer annotated tag (v1.6.3.2~35)
#     branch        relative to newer tag or branch (master~4)
#     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)
#     default       exactly matching tag
#
# If you would like a colored hint about the current dirty state, set
# GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on
# the colored output of "git status -sb".

# __gitdir accepts 0 or 1 arguments (i.e., location)
# returns location of .git repo
__gitdir ()
{
	# Note: this function is duplicated in git-completion.bash
	# When updating it, make sure you update the other one to match.
	if [ -z "${1-}" ]; then
		if [ -n "${__git_dir-}" ]; then
			echo "$__git_dir"
		elif [ -n "${GIT_DIR-}" ]; then
			test -d "${GIT_DIR-}" || return 1
			echo "$GIT_DIR"
		elif [ -d .git ]; then
			echo .git
		else
			git rev-parse --git-dir 2>/dev/null
		fi
	elif [ -d "$1/.git" ]; then
		echo "$1/.git"
	else
		echo "$1"
	fi
}

# stores the divergence from upstream in $p
# used by GIT_PS1_SHOWUPSTREAM
__git_ps1_show_upstream ()
{
	local key value
	local svn_remote svn_url_pattern count n
	local upstream=git legacy="" verbose=""

	svn_remote=()
	# get some config options from git-config
	local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')"
	while read -r key value; do
		case "$key" in
		bash.showupstream)
			GIT_PS1_SHOWUPSTREAM="$value"
			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
				p=""
				return
			fi
			;;
		svn-remote.*.url)
			svn_remote[$((${#svn_remote[@]} + 1))]="$value"
			svn_url_pattern+="\\|$value"
			upstream=svn+git # default upstream is SVN if available, else git
			;;
		esac
	done <<< "$output"

	# parse configuration values
	for option in ${GIT_PS1_SHOWUPSTREAM}; do
		case "$option" in
		git|svn) upstream="$option" ;;
		verbose) verbose=1 ;;
		legacy)  legacy=1  ;;
		esac
	done

	# Find our upstream
	case "$upstream" in
	git)    upstream="@{upstream}" ;;
	svn*)
		# get the upstream from the "git-svn-id: ..." in a commit message
		# (git-svn uses essentially the same procedure internally)
		local -a svn_upstream
		svn_upstream=($(git log --first-parent -1 \
					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null))
		if [[ 0 -ne ${#svn_upstream[@]} ]]; then
			svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}
			svn_upstream=${svn_upstream%@*}
			local n_stop="${#svn_remote[@]}"
			for ((n=1; n <= n_stop; n++)); do
				svn_upstream=${svn_upstream#${svn_remote[$n]}}
			done

			if [[ -z "$svn_upstream" ]]; then
				# default branch name for checkouts with no layout:
				upstream=${GIT_SVN_ID:-git-svn}
			else
				upstream=${svn_upstream#/}
			fi
		elif [[ "svn+git" = "$upstream" ]]; then
			upstream="@{upstream}"
		fi
		;;
	esac

	# Find how many commits we are ahead/behind our upstream
	if [[ -z "$legacy" ]]; then
		count="$(git rev-list --count --left-right \
				"$upstream"...HEAD 2>/dev/null)"
	else
		# produce equivalent output to --count for older versions of git
		local commits
		if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"
		then
			local commit behind=0 ahead=0
			for commit in $commits
			do
				case "$commit" in
				"<"*) ((behind++)) ;;
				*)    ((ahead++))  ;;
				esac
			done
			count="$behind	$ahead"
		else
			count=""
		fi
	fi

	# calculate the result
	if [[ -z "$verbose" ]]; then
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p="=" ;;
		"0	"*) # ahead of upstream
			p=">" ;;
		*"	0") # behind upstream
			p="<" ;;
		*)	    # diverged from upstream
			p="<>" ;;
		esac
	else
		case "$count" in
		"") # no upstream
			p="" ;;
		"0	0") # equal to upstream
			p=" u=" ;;
		"0	"*) # ahead of upstream
			p=" u+${count#0	}" ;;
		*"	0") # behind upstream
			p=" u-${count%	0}" ;;
		*)	    # diverged from upstream
			p=" u+${count#*	}-${count%	*}" ;;
		esac
	fi

}


# __git_ps1 accepts 0 or 1 arguments (i.e., format string)
# when called from PS1 using command substitution
# in this mode it prints text to add to bash PS1 prompt (includes branch name)
#
# __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
# in that case it _sets_ PS1. The arguments are parts of a PS1 string.
# when two arguments are given, the first is prepended and the second appended
# to the state string when assigned to PS1.
# The optional third parameter will be used as printf format string to further
# customize the output of the git-status string.
# In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true
__git_ps1 ()
{
	local pcmode=no
	local detached=no
	local ps1pc_start='\u@\h:\w '
	local ps1pc_end='\$ '
	local printf_format=' (%s)'

	case "$#" in
		2|3)	pcmode=yes
			ps1pc_start="$1"
			ps1pc_end="$2"
			printf_format="${3:-$printf_format}"
		;;
		0|1)	printf_format="${1:-$printf_format}"
		;;
		*)	return
		;;
	esac

	local g="$(__gitdir)"
	if [ -z "$g" ]; then
		if [ $pcmode = yes ]; then
			#In PC mode PS1 always needs to be set
			PS1="$ps1pc_start$ps1pc_end"
		fi
	else
		local r=""
		local b=""
		local step=""
		local total=""
		if [ -d "$g/rebase-merge" ]; then
			b="$(cat "$g/rebase-merge/head-name")"
			step=$(cat "$g/rebase-merge/msgnum")
			total=$(cat "$g/rebase-merge/end")
			if [ -f "$g/rebase-merge/interactive" ]; then
				r="|REBASE-i"
			else
				r="|REBASE-m"
			fi
		else
			if [ -d "$g/rebase-apply" ]; then
				step=$(cat "$g/rebase-apply/next")
				total=$(cat "$g/rebase-apply/last")
				if [ -f "$g/rebase-apply/rebasing" ]; then
					b="$(cat "$g/rebase-apply/head-name")"
					r="|REBASE"
				elif [ -f "$g/rebase-apply/applying" ]; then
					r="|AM"
				else
					r="|AM/REBASE"
				fi
			elif [ -f "$g/MERGE_HEAD" ]; then
				r="|MERGING"
			elif [ -f "$g/CHERRY_PICK_HEAD" ]; then
				r="|CHERRY-PICKING"
			elif [ -f "$g/REVERT_HEAD" ]; then
				r="|REVERTING"
			elif [ -f "$g/BISECT_LOG" ]; then
				r="|BISECTING"
			fi

			test -n "$b" ||
			b="$(git symbolic-ref HEAD 2>/dev/null)" || {
				detached=yes
				b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" ||

				b="$(cut -c1-7 "$g/HEAD" 2>/dev/null)..." ||
				b="unknown"
				b="($b)"
			}
		fi

		if [ -n "$step" ] && [ -n "$total" ]; then
			r="$r $step/$total"
		fi

		local w=""
		local i=""
		local s=""
		local u=""
		local c=""
		local p=""

		if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
			if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
				c="BARE:"
			else
				b="GIT_DIR!"
			fi
		elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then
			if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] &&
			   [ "$(git config --bool bash.showDirtyState)" != "false" ]
			then
				git diff --no-ext-diff --quiet --exit-code || w="*"
				if git rev-parse --quiet --verify HEAD >/dev/null; then
					git diff-index --cached --quiet HEAD -- || i="+"
				else
					i="#"
				fi
			fi
			if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ]; then
				git rev-parse --verify refs/stash >/dev/null 2>&1 && s="$"
			fi

			if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] &&
			   [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] &&
			   [ -n "$(git ls-files --others --exclude-standard)" ]
			then
				u="%${ZSH_VERSION+%}"
			fi

			if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
				__git_ps1_show_upstream
			fi
		fi

		local f="$w$i$s$u"
		if [ $pcmode = yes ]; then
			local gitstring=
			if [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
				local c_red='\e[31m'
				local c_green='\e[32m'
				local c_lblue='\e[1;34m'
				local c_clear='\e[0m'
				local bad_color=$c_red
				local ok_color=$c_green
				local branch_color="$c_clear"
				local flags_color="$c_lblue"
				local branchstring="$c${b##refs/heads/}"

				if [ $detached = no ]; then
					branch_color="$ok_color"
				else
					branch_color="$bad_color"
				fi

				# Setting gitstring directly with \[ and \] around colors
				# is necessary to prevent wrapping issues!
				gitstring="\[$branch_color\]$branchstring\[$c_clear\]"

				if [ -n "$w$i$s$u$r$p" ]; then
					gitstring="$gitstring "
				fi
				if [ "$w" = "*" ]; then
					gitstring="$gitstring\[$bad_color\]$w"
				fi
				if [ -n "$i" ]; then
					gitstring="$gitstring\[$ok_color\]$i"
				fi
				if [ -n "$s" ]; then
					gitstring="$gitstring\[$flags_color\]$s"
				fi
				if [ -n "$u" ]; then
					gitstring="$gitstring\[$bad_color\]$u"
				fi
				gitstring="$gitstring\[$c_clear\]$r$p"
			else
				gitstring="$c${b##refs/heads/}${f:+ $f}$r$p"
			fi
			gitstring=$(printf -- "$printf_format" "$gitstring")
			PS1="$ps1pc_start$gitstring$ps1pc_end"
		else
			# NO color option unless in PROMPT_COMMAND mode
			printf -- "$printf_format" "$c${b##refs/heads/}${f:+ $f}$r$p"
		fi
	fi
}

# fresh: shell/completions/tmux

# START tmux completion
# This file is in the public domain
# See: http://www.debian-administration.org/articles/317 for how to write more.
# Usage: Put "source bash_completion_tmux.sh" into your .bashrc
_tmux()
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    opts=" \
    attach-session \
    bind-key \
    break-pane \
    capture-pane \
    choose-client \
    choose-session \
    choose-window \
    clear-history \
    clock-mode \
    command-prompt \
    confirm-before \
    copy-buffer \
    copy-mode \
    delete-buffer \
    detach-client \
    display-message \
    display-panes \
    down-pane \
    find-window \
    has-session \
    if-shell \
    join-pane \
    kill-pane \
    kill-server \
    kill-session \
    kill-window \
    last-window \
    link-window \
    list-buffers \
    list-clients \
    list-commands \
    list-keys \
    list-panes \
    list-sessions \
    list-windows \
    load-buffer \
    lock-client \
    lock-server \
    lock-session \
    move-window \
    new-session \
    new-window \
    next-layout \
    next-window \
    paste-buffer \
    pipe-pane \
    previous-layout \
    previous-window \
    refresh-client \
    rename-session \
    rename-window \
    resize-pane \
    respawn-window \
    rotate-window \
    run-shell \
    save-buffer \
    select-layout \
    select-pane \
    select-prompt \
    select-window \
    send-keys \
    send-prefix \
    server-info \
    set-buffer \
    set-environment \
    set-option \
    set-window-option \
    show-buffer \
    show-environment \
    show-messages \
    show-options \
    show-window-options \
    source-file \
    split-window \
    start-server \
    suspend-client \
    swap-pane \
    swap-window \
    switch-client \
    unbind-key \
    unlink-window \
    up-pane"

    COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
    return 0

}
complete -F _tmux tmux

# END tmux completion




# fresh: shell/bashrc-mixins/asdf

test -f /opt/homebrew/etc/bash_completion.d/asdf && . /opt/homebrew/etc/bash_completion.d/asdf

type asdf &>/dev/null

if [ $? -eq 0 ]; then
  export ASDF_DATA_DIR=$HOME/.asdf
  export PATH=$ASDF_DATA_DIR/shims:$PATH

  install_ruby_version(){
    jemalloc-config --version || brew install jemalloc
    RUBY_CONFIGURE_OPTS="--with-jemalloc-dir=$(brew --prefix jemalloc) --enable-yjit" asdf install ruby $1
  }
fi

# fresh: shell/bashrc-mixins/assume

which assume &> /dev/null

if [ $? -eq 0 ]; then
  alias assume="source assume"
fi

# fresh: shell/bashrc-mixins/direnv

type direnv &>/dev/null

if [ $? -eq 0 ]; then
  eval "$(direnv hook bash)"
fi

# fresh: shell/bashrc-mixins/extra

if [ -f $HOME/.bashrc-extra ]; then
  source $HOME/.bashrc-extra
fi

# fresh: shell/bashrc-mixins/fixssh

fixssh() {
  for key in SSH_AUTH_SOCK SSH_CONNECTION SSH_CLIENT; do
    if (tmux show-environment | grep "^${key}" > /dev/null); then
      value=`tmux show-environment | grep "^${key}" | sed -e "s/^[A-Z_]*=//"`
      export ${key}="${value}"
    fi
  done
}

# fresh: shell/bashrc-mixins/go

export GOPATH=$HOME/code/go

[ ! -d $GOPATH ] && mkdir -p $GOPATH

# fresh: shell/bashrc-mixins/iterm

function titlepwd() {
  title `pwd`
}

function tab_color() {
  echo -n -e "\033]6;1;bg;red;brightness;$1\a"
  echo -n -e "\033]6;1;bg;green;brightness;$2\a"
  echo -n -e "\033]6;1;bg;blue;brightness;$3\a"
}

function title {
  echo -ne "\033]0;"$*"\007"
  printf "\e]1337;SetBadgeFormat=%s\a"   $(echo -n "$*" | base64)
}

function tab_pure_red { title "$*"; tab_color 255 0 0; }
function tab_pure_orange { title "$*"; tab_color 255 165 0; }
function tab_pure_green { title "$*"; tab_color 0 128 0; }
function tab_pure_blue { title "$*"; tab_color 0 0 255; }
function tab_pure_yellow { title "$*"; tab_color 255 255 0; }

function tab_red()    { title "$*"; tab_color 195  89  76; }
function tab_orange() { title "$*"; tab_color 219 154  88; }
function tab_green()  { title "$*"; tab_color  65 174  76; }
function tab_blue()   { title "$*"; tab_color  92 155 204; }
function tab_yellow() { title "$*"; tab_color 240 240   0; }

function tab_maroon { title "$*"; tab_color 128 0 0; }
function tab_dark_red { title "$*"; tab_color 139 0 0; }
function tab_brown { title "$*"; tab_color 165 42 42; }
function tab_firebrick { title "$*"; tab_color 178 34 34; }
function tab_crimson { title "$*"; tab_color 220 20 60; }
function tab_tomato { title "$*"; tab_color 255 99 71; }
function tab_coral { title "$*"; tab_color 255 127 80; }
function tab_indian_red { title "$*"; tab_color 205 92 92; }
function tab_light_coral { title "$*"; tab_color 240 128 128; }
function tab_dark_salmon { title "$*"; tab_color 233 150 122; }
function tab_salmon { title "$*"; tab_color 250 128 114; }
function tab_light_salmon { title "$*"; tab_color 255 160 122; }
function tab_orange_red { title "$*"; tab_color 255 69 0; }
function tab_dark_orange { title "$*"; tab_color 255 140 0; }
function tab_gold { title "$*"; tab_color 255 215 0; }
function tab_dark_golden_rod { title "$*"; tab_color 184 134 11; }
function tab_golden_rod { title "$*"; tab_color 218 165 32; }
function tab_pale_golden_rod { title "$*"; tab_color 238 232 170; }
function tab_dark_khaki { title "$*"; tab_color 189 183 107; }
function tab_khaki { title "$*"; tab_color 240 230 140; }
function tab_olive { title "$*"; tab_color 128 128 0; }
function tab_yellow_green { title "$*"; tab_color 154 205 50; }
function tab_dark_olive_green { title "$*"; tab_color 85  107 47; }
function tab_olive_drab { title "$*"; tab_color 107 142 35; }
function tab_lawn_green { title "$*"; tab_color 124 252 0; }
function tab_chart_reuse { title "$*"; tab_color 127 255 0; }
function tab_green_yellow { title "$*"; tab_color 173 255 47; }
function tab_dark_green { title "$*"; tab_color 0 100 0; }
function tab_forest_green { title "$*"; tab_color 34  139 34; }
function tab_lime { title "$*"; tab_color 0 255 0; }
function tab_lime_green { title "$*"; tab_color 50  205 50; }
function tab_light_green { title "$*"; tab_color 144 238 144; }
function tab_pale_green { title "$*"; tab_color 152 251 152; }
function tab_dark_sea_green { title "$*"; tab_color 143 188 143; }
function tab_medium_spring_green { title "$*"; tab_color 0 250 154; }
function tab_spring_green { title "$*"; tab_color 0 255 127; }
function tab_sea_green { title "$*"; tab_color 46  139 87; }
function tab_medium_aqua_marine { title "$*"; tab_color 102 205 170; }
function tab_medium_sea_green { title "$*"; tab_color 60  179 113; }
function tab_light_sea_green { title "$*"; tab_color 32  178 170; }
function tab_dark_slate_gray { title "$*"; tab_color 47  79 79; }
function tab_teal { title "$*"; tab_color 0 128 128; }
function tab_dark_cyan { title "$*"; tab_color 0 139 139; }
function tab_aqua { title "$*"; tab_color 0 255 255; }
function tab_cyan { title "$*"; tab_color 0 255 255; }
function tab_light_cyan { title "$*"; tab_color 224 255 255; }
function tab_dark_turquoise { title "$*"; tab_color 0 206 209; }
function tab_turquoise { title "$*"; tab_color 64  224 208; }
function tab_medium_turquoise { title "$*"; tab_color 72  209 204; }
function tab_pale_turquoise { title "$*"; tab_color 175 238 238; }
function tab_aqua_marine { title "$*"; tab_color 127 255 212; }
function tab_powder_blue { title "$*"; tab_color 176 224 230; }
function tab_cadet_blue { title "$*"; tab_color 95  158 160; }
function tab_steel_blue { title "$*"; tab_color 70  130 180; }
function tab_corn_flower_blue { title "$*"; tab_color 100 149 237; }
function tab_deep_sky_blue { title "$*"; tab_color 0 191 255; }
function tab_dodger_blue { title "$*"; tab_color 30  144 255; }
function tab_light_blue { title "$*"; tab_color 173 216 230; }
function tab_sky_blue { title "$*"; tab_color 135 206 235; }
function tab_light_sky_blue { title "$*"; tab_color 135 206 250; }
function tab_midnight_blue { title "$*"; tab_color 25  25_ 112; }
function tab_navy { title "$*"; tab_color 0 0 128; }
function tab_dark_blue { title "$*"; tab_color 0 0 139; }
function tab_medium_blue { title "$*"; tab_color 0 0 205; }
function tab_royal_blue { title "$*"; tab_color 65  105 225; }
function tab_blue_violet { title "$*"; tab_color 138 43 226; }
function tab_indigo { title "$*"; tab_color 75  0 130; }
function tab_dark_slate_blue { title "$*"; tab_color 72  61 139; }
function tab_slate_blue { title "$*"; tab_color 106 90 205; }
function tab_medium_slate_blue { title "$*"; tab_color 123 104 238; }
function tab_medium_purple { title "$*"; tab_color 147 112 219; }
function tab_dark_magenta { title "$*"; tab_color 139 0 139; }
function tab_dark_violet { title "$*"; tab_color 148 0 211; }
function tab_dark_orchid { title "$*"; tab_color 153 50 204; }
function tab_medium_orchid { title "$*"; tab_color 186 85_ 211; }
function tab_purple { title "$*"; tab_color 128 0 128; }
function tab_thistle { title "$*"; tab_color 216 191 216; }
function tab_plum { title "$*"; tab_color 221 160 221; }
function tab_violet { title "$*"; tab_color 238 130 238; }
function tab_magenta_fuchsia { title "$*"; tab_color 255 0 255; }
function tab_orchid { title "$*"; tab_color 218 112 214; }
function tab_medium_violet_red { title "$*"; tab_color 199 21 133; }
function tab_pale_violet_red { title "$*"; tab_color 219 112 147; }
function tab_deep_pink { title "$*"; tab_color 255 20 147; }
function tab_hot_pink { title "$*"; tab_color 255 105 180; }
function tab_light_pink { title "$*"; tab_color 255 182 193; }
function tab_pink { title "$*"; tab_color 255 192 203; }
function tab_antique_white { title "$*"; tab_color 250 235 215; }
function tab_beige { title "$*"; tab_color 245 245 220; }
function tab_bisque { title "$*"; tab_color 255 228 196; }
function tab_blanched_almond { title "$*"; tab_color 255 235 205; }
function tab_wheat { title "$*"; tab_color 245 222 179; }
function tab_corn_silk { title "$*"; tab_color 255 248 220; }
function tab_lemon_chiffon { title "$*"; tab_color 255 250 205; }
function tab_light_golden_rod_yellow { title "$*"; tab_color 250 250 210; }
function tab_light_yellow { title "$*"; tab_color 255 255 224; }
function tab_saddle_brown { title "$*"; tab_color 139 69 19; }
function tab_sienna { title "$*"; tab_color 160 82 45; }
function tab_chocolate { title "$*"; tab_color 210 105 30; }
function tab_peru { title "$*"; tab_color 205 133 63; }
function tab_sandy_brown { title "$*"; tab_color 244 164 96; }
function tab_burly_wood { title "$*"; tab_color 222 184 135; }
function tab_tan { title "$*"; tab_color 210 180 140; }
function tab_rosy_brown { title "$*"; tab_color 188 143 143; }
function tab_moccasin { title "$*"; tab_color 255 228 181; }
function tab_navajo_white { title "$*"; tab_color 255 222 173; }
function tab_peach_puff { title "$*"; tab_color 255 218 185; }
function tab_misty_rose { title "$*"; tab_color 255 228 225; }
function tab_lavender_blush { title "$*"; tab_color 255 240 245; }
function tab_linen { title "$*"; tab_color 250 240 230; }
function tab_old_lace { title "$*"; tab_color 253 245 230; }
function tab_papaya_whip { title "$*"; tab_color 255 239 213; }
function tab_sea_shell { title "$*"; tab_color 255 245 238; }
function tab_mint_cream { title "$*"; tab_color 245 255 250; }
function tab_slate_gray { title "$*"; tab_color 112 128 144; }
function tab_light_slate_gray { title "$*"; tab_color 119 136 153; }
function tab_light_steel_blue { title "$*"; tab_color 176 196 222; }
function tab_lavender { title "$*"; tab_color 230 230 250; }
function tab_floral_white { title "$*"; tab_color 255 250 240; }
function tab_alice_blue { title "$*"; tab_color 240 248 255; }
function tab_ghost_white { title "$*"; tab_color 248 248 255; }
function tab_honeydew { title "$*"; tab_color 240 255 240; }
function tab_ivory { title "$*"; tab_color 255 255 240; }
function tab_azure { title "$*"; tab_color 240 255 255; }
function tab_snow { title "$*"; tab_color 255 250 250; }
function tab_black { title "$*"; tab_color 0 0 0; }
function tab_dim_gray_dim_grey { title "$*"; tab_color 105 105 105; }
function tab_gray_grey { title "$*"; tab_color 128 128 128; }
function tab_dark_gray_dark_grey { title "$*"; tab_color 169 169 169; }
function tab_silver { title "$*"; tab_color 192 192 192; }
function tab_light_gray_light_grey { title "$*"; tab_color 211 211 211 ; }
function tab_gainsboro { title "$*"; tab_color 220 220 220; }
function tab_white_smoke { title "$*"; tab_color 245 245 245; }
function tab_white { title "$*"; tab_color 255 255 255; }

# fresh: shell/bashrc-mixins/mise

type mise &>/dev/null

if [ $? -eq 0 ]; then
  eval "$(mise activate bash)"

  install_ruby_version(){
    if [ "$(uname)" = "Darwin" ]; then
      RUBY_CONFIGURE_OPTS="--with-jemalloc-dir=$(brew --prefix jemalloc) --enable-yjit" mise use ruby@$1
    else
      RUBY_CONFIGURE_OPTS="--with-jemalloc --enable-yjit" mise use ruby@$1
    fi
  }
fi

# load z/rupa script
. "${HOME}/z.sh"
